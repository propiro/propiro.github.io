<!DOCTYPE html><html lang="en-gb"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>MACROSCRIPT: InsetFix Smoothgroup Modifier - propiro.github.io</title><meta name="description" content="technical art, industry rants, 3d, hacking, 3d printing, amateur arnaments, cats."><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="https://propiro.github.io/macroscript-insetfix-smoothgroup-modifier.html"><link rel="amphtml" href="https://propiro.github.io/amp/macroscript-insetfix-smoothgroup-modifier.html"><link rel="alternate" type="application/atom+xml" href="https://propiro.github.io/feed.xml"><link rel="alternate" type="application/json" href="https://propiro.github.io/feed.json"><meta property="og:title" content="MACROSCRIPT: InsetFix Smoothgroup Modifier"><meta property="og:image" content="https://propiro.github.io/media/website/distantgunfire.png"><meta property="og:site_name" content="propiro.github.io "><meta property="og:description" content="technical art, industry rants, 3d, hacking, 3d printing, amateur arnaments, cats."><meta property="og:url" content="https://propiro.github.io/macroscript-insetfix-smoothgroup-modifier.html"><meta property="og:type" content="article"><meta name="twitter:card" content="summary"><meta name="twitter:site" content="@propiro"><meta name="twitter:title" content="MACROSCRIPT: InsetFix Smoothgroup Modifier"><meta name="twitter:description" content="technical art, industry rants, 3d, hacking, 3d printing, amateur arnaments, cats."><meta name="twitter:image" content="https://propiro.github.io/media/website/distantgunfire.png"><link rel="shortcut icon" href="https://propiro.github.io/media/website/icons8-automatic-50.png" type="image/x-icon"><link rel="stylesheet" href="https://propiro.github.io/assets/css/style.css?v=88cf7d27f7757b5e9bfd48ef2d2c98ca"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://propiro.github.io/macroscript-insetfix-smoothgroup-modifier.html"},"headline":"MACROSCRIPT: InsetFix Smoothgroup Modifier","datePublished":"2023-02-15T11:03","dateModified":"2023-02-15T11:03","description":"technical art, industry rants, 3d, hacking, 3d printing, amateur arnaments, cats.","author":{"@type":"Person","name":"piro","url":"https://propiro.github.io/authors/piro/"},"publisher":{"@type":"Organization","name":"piro"}}</script></head><body><div class="container js-container"><nav class="menu"><ul class="navbar__menu"><li><span>./MAIN/</span></li><li><a href="https://propiro.github.io//" target="_self">./MAIN/ALL</a></li><li class="has-submenu"><span>./MAIN/WORK/</span><ul class="navbar__submenu"><li><a href="https://propiro.github.io/maxscript/" target="_self">./MAIN/WORK/maxscript/</a></li><li><a href="https://propiro.github.io/3d-tag/" target="_self">./MAIN/WORK/3d/</a></li><li><a href="https://propiro.github.io/gamedev/" target="_self">./MAIN/WORK/gamedev/</a></li></ul></li><li class="has-submenu"><a href="https://propiro.github.io/hacks/" target="_self">./MAIN/SOCIAL/</a><ul class="navbar__submenu"><li><a href="https://propiro.github.io/internet/" target="_self">./MAIN/SOCIAL/internet/</a></li><li><a href="https://propiro.github.io/general_rant/" target="_self">./MAIN/SOCIAL/rant/</a></li><li><a href="https://propiro.github.io/other/" target="_self">./MAIN/SOCIAL/misc</a></li><li class="has-submenu"><span>./MAIN/SOCIAL/friend_sites</span><ul class="navbar__submenu"><li><a href="https://pidpawel.eu" target="_self">/pid</a></li></ul></li></ul></li><li class="has-submenu"><a href="https://propiro.github.io/shopping/" target="_self">./MAIN/NOT_WORK/</a><ul class="navbar__submenu"><li><a href="https://propiro.github.io/hacks/" target="_self">./MAIN/NOT_WORK/hacks/</a></li><li><a href="https://propiro.github.io/shopping/" target="_self">./MAIN/NOT_WORK/shopping</a></li><li><a href="https://propiro.github.io/diy/" target="_self">./MAIN/NOT_WORK/diy/</a></li><li><a href="https://propiro.github.io/hardware/" target="_self">./MAIN/NOT_WORK/hardware/</a></li></ul></li></ul></nav><div class="content"><header class="top"><div class="top__item"><a class="logo" href="https://propiro.github.io/">propiro.github.io</a></div><div class="top__item top__item--right"><button class="menu-toggle js-menu-toggle" aria-label="Menu" aria-expanded="false"><span class="menu-toggle-box"><span class="menu-toggle-inner">Menu</span></span></button></div></header><main class="main"><article class="post"><div class="main__left"><figure class="hero"><img src="https://propiro.github.io/media/website/2019-12-18_11h57_18a.jpg" srcset="https://propiro.github.io/media/website/responsive/2019-12-18_11h57_18a-xs.jpg 300w, https://propiro.github.io/media/website/responsive/2019-12-18_11h57_18a-sm.jpg 480w, https://propiro.github.io/media/website/responsive/2019-12-18_11h57_18a-md.jpg 768w, https://propiro.github.io/media/website/responsive/2019-12-18_11h57_18a-lg.jpg 1024w, https://propiro.github.io/media/website/responsive/2019-12-18_11h57_18a-xl.jpg 1280w, https://propiro.github.io/media/website/responsive/2019-12-18_11h57_18a-2xl.jpg 1600w" sizes="(min-width: 1800px) 50vw, (min-width: 900px) 40vw, 100vw" loading="eager" width="750" height="908" alt=""></figure><header><h1>MACROSCRIPT: InsetFix Smoothgroup Modifier</h1><p><time datetime="2023-02-15T11:03">15/02/2023 </time>by <a href="https://propiro.github.io/authors/piro/" rel="author" title="piro">piro</a></p></header></div><div class="main__right"><div class="post__entry"><p>Note: This script isn't mine, but its made by very talented Vojtech Cada - I'm reposting it here mostly for myself, so I wont lose it, and to show some viewers. Original link it was grabbed from is: <a href="http://www.scriptspot.com/3ds-max/scripts/insetfix-modifier">http://www.scriptspot.com/3ds-max/scripts/insetfix-modifier</a><a href="http://www.scriptspot.com/3ds-max/scripts/insetfix-modifier"></a></p><p>Some time ago I've included InsetFix to my workflow, and it speeds up modelling by a lot. See the difference between build-in 3ds max inset (left), applied per-smoothgroup, and InsetFix (right):</p><figure class="post__image"><img loading="lazy" src="https://propiro.github.io/media/posts/38/2023-02-15_11h00_15.png" sizes="(min-width: 1500px) calc(7.87vw + 610px), (min-width: 900px) calc(44.48vw + 68px), (min-width: 780px) calc(8vw + 604px), calc(84.35vw + 23px)" srcset="https://propiro.github.io/media/posts/38/responsive/2023-02-15_11h00_15-xs.png 300w, https://propiro.github.io/media/posts/38/responsive/2023-02-15_11h00_15-sm.png 480w, https://propiro.github.io/media/posts/38/responsive/2023-02-15_11h00_15-md.png 768w" alt="" width="2392" height="1772"><figcaption>All the corners, nicely prepared for applying meshsmooth!</figcaption></figure><p>As you can see, after mesh have correctly set smoothgroups, it automatically creates good base topology for applying subdivision, with corners protected by edges.</p><p>Code for script, in case you cant download it from scriptspot anymore - save it as InsetFix.ms, put in startup folder (or execute manually every time), and you'll find InsetFix on modifier list:</p><p><code>plugin simpleMeshMod insetSGFix</code><br><code>    name:"InsetSGFix"</code><br><code>    classID:#(0xc4e63a8, 0x2a9ccb40)</code><br><code>--    author:"Vojtech Cada"</code><br><code>(</code><br><code>    parameters main rollout:params</code><br><code>    (</code><br><code>        inset type:#worldUnits default:0 ui:spnInset</code><br><code>    )</code><br><br><code>    rollout params "Parameters"</code><br><code>    (</code><br><code>        spinner spnInset "Inset: " type:#worldUnits range:[1e-9, 1e9, 0]</code><br><code>    )</code><br><br><code>    local faceIndex</code><br><br><code>    fn getFaceEdge face edge =</code><br><code>        (face - 1) * 3 + edge</code><br><br><code>    fn getFaceVert face index =</code><br><code>        int (getFace mesh face)[index]</code><br><br><code>    fn getReverseEdge edge =</code><br><code>        ((meshop.getEdgesReverseEdge mesh edge) as array)[1]</code><br><br><code>    fn getProjectedInset edge =</code><br><code>        meshop.getVert mesh edge.insetVertA - edge.vertAPos</code><br><br><code>    struct orientedEdge</code><br><code>    (</code><br><code>        -- vert indices:</code><br><code>        vertA, vertAPos, insetVertA, innerVertA = vertA, innerInsetVertA,</code><br><code>        vertB, vertBPos, insetVertB, innerVertB = vertB, innerInsetVertB,</code><br><br><code>        face, -- the face that the edge belongs to</code><br><code>        vertAFaceIndex, -- index of vertA in the face</code><br><code>        vertBFaceIndex, -- index of vertB in the face</code><br><br><code>        isEdgeCornerAReflex = false, innerOffsetA,</code><br><code>        isEdgeCornerBReflex = false, innerOffsetB,</code><br><br><code>        smoothGroup,</code><br><code>        active = true, -- when active, no faces were created for this edge yet</code><br><code>        divided = false,</code><br><code>        dir = normalize (vertBPos - vertAPos), -- edge direction</code><br><code>        index = (face - 1) * 3 + vertAFaceIndex, -- edge index</code><br><br><code>        fn getInsetVert vertFaceIndex =</code><br><code>            getFaceVert face vertFaceIndex,</code><br><br><code>        fn getEdgeDiv offset =</code><br><code>            offset / distance (meshop.getVert mesh insetVertA) \</code><br><code>                              (meshop.getVert mesh insetVertB),</code><br><br><code>        fn insertCornerVertA div =</code><br><code>        (</code><br><code>            meshop.divideEdge mesh index (getEdgeDiv div) fixNeighbors:false</code><br><code>            innerInsetVertA = mesh.numVerts</code><br><code>        ),</code><br><br><code>        fn insertCornerVertB div =</code><br><code>        (</code><br><code>            meshop.divideEdge mesh index (1 - getEdgeDiv div) fixNeighbors:false</code><br><code>            innerInsetVertB = mesh.numVerts</code><br><code>        ),</code><br><br><code>        fn initInsetVerts =</code><br><code>        (</code><br><code>            innerInsetVertA = insetVertA = getInsetVert vertAFaceIndex</code><br><code>            innerInsetVertB = insetVertB = getInsetVert vertBFaceIndex</code><br><code>        )</code><br><code>    )</code><br><br><code>    struct edgePair</code><br><code>    (</code><br><code>        smoothGroup,</code><br><br><code>        edgeA, edgeReverseA,</code><br><code>        edgeB, edgeReverseB,</code><br><br><code>        innerEdgeA = getReverseEdge edgeA.index,</code><br><code>        innerEdgeB = getReverseEdge edgeB.index,</code><br><br><code>        innerOffset = dot edgeA.dir (getProjectedInset edgeA),</code><br><code>        isAngleReflex = innerOffset &lt; 0,</code><br><code>        isEdgeCornerReflex,</code><br><br><code>        fn insertCornerVertA = edgeA.insertCornerVertA (inset - innerOffset),</code><br><code>        fn insertCornerVertB = edgeB.insertCornerVertB (inset - innerOffset),</code><br><br><code>        fn insertCornerVerts edge =</code><br><code>        (</code><br><code>            local divA = edge.getEdgeDiv (inset - edge.innerOffsetA)</code><br><code>            local divB = edge.getEdgeDiv (inset - edge.innerOffsetB)</code><br><br><code>            meshop.divideEdge mesh edge.index divA fixNeighbors:false</code><br><code>            meshop.divideEdge mesh edge.index (1 - divB / (1 - divA)) fixNeighbors:false</code><br><br><code>            edge.innerInsetVertB = mesh.numVerts</code><br><code>            edge.innerInsetVertA = edge.innerInsetVertB - 1 </code><br><code>        ),</code><br><br><code>        fn divideEdge edge isEdgeCornerReflex insertCornerVert =</code><br><code>            if isEdgeCornerReflex then</code><br><code>            (</code><br><code>                if not edge.divided do</code><br><code>                (</code><br><code>                    insertCornerVerts edge</code><br><code>                    edge.divided = true</code><br><code>                )</code><br><code>            )</code><br><code>            else insertCornerVert(),</code><br><br><code>        fn divideEdgeA = divideEdge edgeA edgeA.isEdgeCornerBReflex insertCornerVertA,</code><br><code>        fn divideEdgeB = divideEdge edgeB edgeB.isEdgeCornerAReflex insertCornerVertB,</code><br><br><code>        fn addCornerFaces =</code><br><code>            if isAngleReflex then</code><br><code>            (</code><br><code>                meshop.createPolygon mesh #(edgeA.vertA, edgeA.innerVertA, edgeA.innerInsetVertA, edgeA.insetVertA)</code><br><code>                meshop.createPolygon mesh #(edgeB.innerVertB, edgeB.vertB, edgeB.insetVertB, edgeB.innerInsetVertB)</code><br><code>                faceIndex += 4</code><br><code>                #{getFaceEdge (faceIndex - 3) 1, getFaceEdge (faceIndex - 1) 2}</code><br><code>            )</code><br><code>            else</code><br><code>            (</code><br><code>                meshop.createPolygon mesh #(edgeA.vertA, edgeA.innerVertA, edgeA.insetVertA, edgeB.innerVertB)</code><br><code>                faceIndex += 2</code><br><code>                #{getFaceEdge (faceIndex - 1) 1, getFaceEdge (faceIndex) 3}</code><br><code>            ),</code><br><br><code>        fn addJointQuads =</code><br><code>        ((</code><br><code>            if not edgeA.active then #{} else</code><br><code>            (</code><br><code>                meshop.createPolygon mesh #(edgeA.innerVertA, edgeA.innerVertB, edgeA.innerInsetVertB, edgeA.innerInsetVertA)</code><br><code>                faceIndex += 2</code><br><code>                #{getFaceEdge (faceIndex - 1) 1}</code><br><code>            )) + (</code><br><code>            if not edgeB.active then #{} else</code><br><code>            (</code><br><code>                meshop.createPolygon mesh #(edgeB.innerInsetVertA, edgeB.innerVertA, edgeB.innerVertB, edgeB.innerInsetVertB)</code><br><code>                faceIndex += 2</code><br><code>                #{getFaceEdge (faceIndex - 1) 2}</code><br><code>            ))</code><br><code>        ),</code><br><br><code>        on create do</code><br><code>        (</code><br><code>            edgeA.isEdgeCornerAReflex = edgeB.isEdgeCornerBReflex = isAngleReflex</code><br><code>            edgeA.innerOffsetA = edgeB.innerOffsetB = innerOffset</code><br><code>        )</code><br><code>    )</code><br><br><code>    struct corner</code><br><code>    (</code><br><code>        edges,</code><br><code>        reverseEdges,</code><br><code>        oppositeEdges = #(),</code><br><code>        edgePairs,</code><br><br><code>        on create do edgePairs =</code><br><code>            for i = 1 to edges.count collect</code><br><code>            (</code><br><code>                local edgeA = edges[i]</code><br><code>                local edgeB = reverseEdges[i]</code><br><code>                edgeA.initInsetVerts()</code><br><code>                edgeB.initInsetVerts()</code><br><br><code>                edgePair smoothGroup:edgeA.smoothGroup edgeA:edgeA edgeB:edgeB \</code><br><code>                         edgeReverseA:(for edge in reverseEdges where edge.vertA == edgeA.vertB do exit with edge) \</code><br><code>                         edgeReverseB:(for edge in edges where edge.vertB == edgeB.vertA do exit with edge)</code><br><code>            )</code><br><code>    )</code><br><br><code>    fn comparevertA i1 i2 =</code><br><code>        if i1.vertA == i2.vertA then</code><br><code>            i1.smoothGroup - i2.smoothGroup</code><br><code>        else i1.vertA - i2.vertA</code><br><br><code>    fn comparevertB i1 i2 =</code><br><code>        if i1.vertB == i2.vertB then</code><br><code>            i1.smoothGroup - i2.smoothGroup</code><br><code>        else i1.vertB - i2.vertB</code><br><br><code>    fn wrapFaceIndex index =</code><br><code>        int(mod (index - 1) 3) + 1</code><br><br><code>    fn getEdgeFace edge =</code><br><code>        if edge == undefined then 0 else (edge - 1) / 3 + 1</code><br><br><code>    fn getReverseFace edge =</code><br><code>        getEdgeFace (getReverseEdge edge)</code><br><br><code>    fn getOppositeFace face edge =</code><br><code>        getReverseFace (getFaceEdge face edge)</code><br><br><code>    fn makeEdge index face faceVerts smoothGroup =</code><br><code>    (</code><br><code>        local vertA = int faceVerts[index]</code><br><code>        local vertB = int faceVerts[wrapFaceIndex (index + 1)]</code><br><br><code>        orientedEdge vertA:vertA vertAPos:(meshop.getVert mesh vertA) \</code><br><code>                     vertB:vertB vertBPos:(meshop.getVert mesh vertB) \</code><br><code>                     vertAFaceIndex:index vertBFaceIndex:(wrapFaceIndex (index + 1)) \</code><br><code>                     face:face smoothGroup:smoothGroup</code><br><code>    )</code><br><br><code>    fn getSGElements mesh =</code><br><code>    (</code><br><code>        local vertCount = mesh.numVerts</code><br><code>        local done = #{}, faces = mesh.faces as bitArray -- all the mesh face indices, will be eliminated one by one</code><br><code>        local facesByVert = for v = 1 to vertCount collect #() -- list of faces sharing the individual verts, filled in the next step:</code><br><br><code>        for face in faces do</code><br><code>        (</code><br><code>            local faceVerts = getFace mesh face</code><br><code>            append facesByVert[faceVerts[1]] face</code><br><code>            append facesByVert[faceVerts[2]] face</code><br><code>            append facesByVert[faceVerts[3]] face</code><br><code>        )</code><br><br><code>        -- collect and return element data:</code><br><code>        for face in faces collect</code><br><code>        (</code><br><code>            local i = 0 -- dynamic index, incremented in while loop, tries to get next appended face</code><br><code>            local element = #(face) -- get one of the remaining faces</code><br><code>            local border = #() -- SG border verts</code><br><code>            local elementSG = getFaceSmoothGroup mesh face -- get its SG</code><br><br><code>            -- while there's still at least one other face appended in the previous while iteration:</code><br><code>            while (local f = element[i += 1]) != undefined do if faces[f] /* and we haven't seen that face before */ do</code><br><code>            (</code><br><code>                faces[f] = false -- remove that face from candidate pool</code><br><code>                append done f -- could be merged with faces check, though it reads easier this way</code><br><code>                local faceVerts = getFace mesh f -- get its three verts</code><br><code>                local vertBuffer = 0 -- face verts sharing different SG encoded as bits</code><br><code>                local faceBuffer = #{} -- faces across the SG border</code><br><br><code>                for v = 1 to 3 do</code><br><code>                (</code><br><code>                    local vert = int(faceVerts[v]) -- indexed face vertex</code><br><br><code>                    -- for faces sharing the given vert:</code><br><code>                    for vertFace in facesByVert[vert] do</code><br><code>                        if getFaceSmoothGroup mesh vertFace == elementSG then -- it's the same SG</code><br><code>                            if not done[vertFace] do -- we haven't seen it before</code><br><code>                            (</code><br><code>                                append element vertFace -- append it to the current element</code><br><code>                                append done vertFace -- append to the list of previously appended faces</code><br><code>                            )</code><br><code>                        else -- doesn't share the same SG</code><br><code>                        (</code><br><code>                            vertBuffer = bit.set vertBuffer v true -- add the vertex to SG border verts buffer</code><br><code>                            faceBuffer[vertFace] = true -- add the face to border face buffer</code><br><code>                            vertFace -- collect it with the rest of remaining facesByVert</code><br><code>                        )</code><br><code>                )</code><br><br><code>                case vertBuffer of</code><br><code>                (</code><br><code>                    3: if (fInv = getOppositeFace f 1) == 0 or faceBuffer[fInv] do </code><br><code>                        append border (makeEdge 1 f faceVerts elementSG) -- verts 1 and 2</code><br><code>                    6: if (fInv = getOppositeFace f 2) == 0 or faceBuffer[fInv] do</code><br><code>                        append border (makeEdge 2 f faceVerts elementSG) -- verts 2 and 3</code><br><code>                    5: if (fInv = getOppositeFace f 3) == 0 or faceBuffer[fInv] do</code><br><code>                        append border (makeEdge 3 f faceVerts elementSG) -- verts 1 and 3</code><br><code>                    7: for ei = 1 to 3 where (fInv = getOppositeFace f ei) == 0 or faceBuffer[fInv] do</code><br><code>                        append border (makeEdge ei f faceVerts elementSG) -- verts 1, 2, 3</code><br><code>                )</code><br><code>            )</code><br><br><code>             -- collect a tuple (faces with the same SG, SG border edges):</code><br><code>            dataPair faces:(element as bitArray) border:border</code><br><code>        )</code><br><code>    )</code><br><br><code>    fn cornersFromSortedBorder border type: =</code><br><code>    (</code><br><code>        local i = 1, edgeCount = border.count</code><br><code>        local corners = #()</code><br><br><code>        while i &lt; edgeCount do</code><br><code>        (</code><br><code>            local vert = getProperty border[i] type</code><br><code>            local corner = #()</code><br><br><code>            -- append one and continue getting while the ones following share the same index:</code><br><code>            do append corner border[i]</code><br><code>            while i &lt; edgeCount and getProperty border[i += 1] type == vert</code><br><br><code>            append corners corner</code><br><code>        )</code><br><code>        return corners</code><br><code>    )</code><br><br><code>    on modifyMesh do</code><br><code>    (</code><br><code>        local border = #(), selectedEdges = #(), facesToDelete = #{}</code><br><code>        local faceCount = mesh.numFaces</code><br><code>        local elements = getSGElements mesh</code><br><br><code>        for element in elements do</code><br><code>        (</code><br><code>            meshOp.extrudeFaces mesh element.faces 0 -inset</code><br><code>            join border element.border</code><br><code>        )</code><br><br><code>        if mesh.numFaces &gt; faceCount do</code><br><code>        (</code><br><code>            -- select new faces:</code><br><code>            local selectedFaces = setFaceSelection mesh #{faceCount + 1 .. mesh.numFaces} as array</code><br><br><code>            -- collect new edges for selection:</code><br><code>            local edge = (selectedFaces[1] - 1) * 3 + 1</code><br><code>            local selectedEdges = #{edge}</code><br><code>            for f = 3 to selectedFaces.count by 2 do append selectedEdges (edge += 6)</code><br><br><code>            -- sort all the border verts by the first edge vertex index:</code><br><code>            qSort border comparevertA</code><br><code>            local corners = cornersFromSortedBorder border type:#vertA</code><br><br><code>            -- sort all the border verts by the second edge vertex index:</code><br><code>            qSort border comparevertB</code><br><code>            local reverseCorners = cornersFromSortedBorder border type:#vertB</code><br><br><code>            -- corners sharing more than two smoothing groups:</code><br><code>            local multiCorners = for c = 1 to corners.count where corners[c].count &gt; 2 collect</code><br><code>                corner edges:corners[c] reverseEdges:reverseCorners[c]</code><br><br><code>            -- get corner support points count:</code><br><code>            local cornerPtsCount = 0</code><br><code>            for corner in multiCorners do cornerPtsCount += corner.edges.count</code><br><br><code>            -- add corner support points:</code><br><code>            local vertCount = mesh.numVerts</code><br><code>            setNumVerts mesh (vertCount + cornerPtsCount) true</code><br><br><code>            -- set and add vertices:</code><br><code>            for corner in multiCorners do for pair in corner.edgePairs do</code><br><code>            (</code><br><code>                setVert mesh (vertCount += 1) (pair.edgeA.vertAPos + inset * pair.edgeA.dir)</code><br><code>                pair.edgeA.innerVertA = pair.edgeReverseA.innerVertB = vertCount</code><br><br><code>                if pair.isAngleReflex do</code><br><code>                (</code><br><code>                    pair.divideEdgeA()</code><br><code>                    pair.divideEdgeB()</code><br><code>                )</code><br><code>            )</code><br><br><code>            faceIndex = mesh.numFaces</code><br><br><code>            -- add polygons:</code><br><code>            for corner in multiCorners do for pair in corner.edgePairs do</code><br><code>            (</code><br><code>                join facesToDelete (meshop.getPolysUsingEdge mesh pair.innerEdgeA)</code><br><code>                join facesToDelete (meshop.getPolysUsingEdge mesh pair.innerEdgeB)</code><br><br><code>                selectedEdges += pair.addCornerFaces()</code><br><code>                selectedEdges += pair.addJointQuads()</code><br><br><code>                -- mark all used edges inactive:</code><br><code>                pair.edgeA.active = false</code><br><code>                pair.edgeB.active = false</code><br><code>            )</code><br><br><code>            setEdgeSelection mesh selectedEdges</code><br><code>            meshop.deleteFaces mesh facesToDelete delIsoVerts:false</code><br><code>        )</code><br><code>    )</code><br><code>)</code></p><p> </p><p> </p><p> </p><footer><div class="post__tag-share"><ul class="post__tag"><li><a href="https://propiro.github.io/3d-tag/">3d</a></li><li><a href="https://propiro.github.io/maxscript/">maxscript</a></li><li><a href="https://propiro.github.io/quick_3d_tips/">quick_3d_tips</a></li></ul><div class="post__share"><a href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fpropiro.github.io%2Fmacroscript-insetfix-smoothgroup-modifier.html" class="js-share facebook" aria-label="Share with Facebook" rel="nofollow noopener noreferrer"><svg class="icon"><use xlink:href="https://propiro.github.io/assets/svg/svg-map.svg#facebook"/></svg> </a><a href="https://twitter.com/share?url=https%3A%2F%2Fpropiro.github.io%2Fmacroscript-insetfix-smoothgroup-modifier.html&amp;via=%40piropro&amp;text=MACROSCRIPT%3A%20InsetFix%20Smoothgroup%20Modifier" class="js-share twitter" aria-label="Share with Twitter" rel="nofollow noopener noreferrer"><svg class="icon"><use xlink:href="https://propiro.github.io/assets/svg/svg-map.svg#twitter"/></svg> </a><a href="https://pinterest.com/pin/create/button/?url=https%3A%2F%2Fpropiro.github.io%2Fmacroscript-insetfix-smoothgroup-modifier.html&amp;media=undefined&amp;description=MACROSCRIPT%3A%20InsetFix%20Smoothgroup%20Modifier" class="js-share pinterest" aria-label="Share with Pinterest" rel="nofollow noopener noreferrer"><svg class="icon"><use xlink:href="https://propiro.github.io/assets/svg/svg-map.svg#pinterest"/></svg> </a><a href="https://buffer.com/add?text=MACROSCRIPT%3A%20InsetFix%20Smoothgroup%20Modifier&amp;url=https%3A%2F%2Fpropiro.github.io%2Fmacroscript-insetfix-smoothgroup-modifier.html" class="js-share buffer" aria-label="Share with Buffer" rel="nofollow noopener noreferrer"><svg class="icon"><use xlink:href="https://propiro.github.io/assets/svg/svg-map.svg#buffer"/></svg></a></div></div></footer></div></div></article><div class="main__right"></div></main><footer class="footer"><div class="footer__copyright"><p class="align-right">      This is just a footer. If you want, you can contact me on:</p><p class="align-right">      <a href="mailto:pro.piro+ghpages@gmail.com"> pro.piro[at]gmail.com</a></p><script type="text/javascript" src="//counter.websiteout.net/js/36/10/231/0"></script></div></footer></div></div><script defer="defer" src="https://propiro.github.io/assets/js/scripts.min.js?v=27706a8fe221267c1834098c796f44c1"></script><script>var images = document.querySelectorAll('img[loading]');
   
           for (var i = 0; i < images.length; i++) {
               if (images[i].complete) {
                   images[i].classList.add('is-loaded');
               } else {
                   images[i].addEventListener('load', function () {
                       this.classList.add('is-loaded');
                   }, false);
               }
           }</script></body></html>