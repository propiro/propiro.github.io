<!doctype html><html amp lang="en-gb"><head><meta charset="utf-8"><title>MAXSCRIPT: InsetFix Smoothgroup Modifier - propiro.github.io</title><meta name="description" content="technical art, industry rants, 3d, hacking, 3d printing, amateur armaments, cats."><link rel="canonical" href="https://propiro.github.io/macroscript-insetfix-smoothgroup-modifier.html"><meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1"><link href="https://fonts.googleapis.com/css?family=Roboto:400,700&display=swap" rel="stylesheet" type="text/css"><script async custom-element="amp-sidebar" src="https://cdn.ampproject.org/v0/amp-sidebar-0.1.js"></script><script async custom-element="amp-social-share" src="https://cdn.ampproject.org/v0/amp-social-share-0.1.js"></script><script async custom-element="amp-iframe" src="https://cdn.ampproject.org/v0/amp-iframe-0.1.js"></script><script async custom-element="amp-video" src="https://cdn.ampproject.org/v0/amp-video-0.1.js"></script><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://propiro.github.io/amp/macroscript-insetfix-smoothgroup-modifier.html"},"headline":"MAXSCRIPT: InsetFix Smoothgroup Modifier","datePublished":"2023-02-15T11:03","dateModified":"2023-04-16T23:43","description":"technical art, industry rants, 3d, hacking, 3d printing, amateur armaments, cats.","author":{"@type":"Person","name":"piro","url":"https://propiro.github.io/amp/authors/piro/"},"publisher":{"@type":"Organization","name":"piro"}}</script><style amp-custom>article,
aside,
footer,
header,
hgroup,
main,
nav,
section {
  display: block; }

*,
*:before,
*:after {
  -webkit-box-sizing: content-box;
  box-sizing: content-box;
  margin: 0;
  padding: 0; }

li {
  list-style: none; }

amp-img {
  max-width: 100%; }

button,
input,
select,
textarea {
  font: inherit; }

html {
  font-size: 1rem; }

body {
  background: #f1f1f1;
  color: #262626;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif;
  line-height: 1.6; }

a {
  color:  #039be5;
  text-decoration: none;
  -webkit-transition: all 0.12s linear 0s;
  -o-transition: all 0.12s linear 0s;
  transition: all 0.12s linear 0s; }

a:hover {
  color: #262626;
  text-decoration: underline;
  -webkit-text-decoration-skip: ink;
  text-decoration-skip: ink; }

a:active {
  color: #262626; }

a:focus {
  outline: 2px dotted #039be5; }

figure,
blockquote,
p,
ul,
ol,
dl,
table,
hr,
fieldset {
  margin-top: 1.6rem; }

h1,
h2,
h3,
h4,
h5,
h6 {
  color: #262626;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif;
  font-weight: 500;
  line-height: 1.2;
  margin-top: 2.13333rem; }

h1 {
  font-size: 1.67583rem;
  font-weight: normal; }

h2 {
  font-size: 1.4729rem; }

h3 {
  font-size: 1.29454rem; }

h4 {
  font-size: 1.13778rem; }

h5 {
  font-size: 1rem; }

h6 {
  font-size: 0.87891rem; }

h2 + p,
h3 + p,
h4 + p,
h5 + p,
h6 + p {
  margin-top: 0.8rem; }

b,
strong {
  font-weight: 600; }

blockquote {
  color: #6c7175;
  font-family: "Droid Serif", "Times", "Source Serif Pro", serif;
  font-style: italic;
  padding: 1.33333rem 0.53333rem 1.33333rem 3.2rem;
  position: relative; }
  blockquote:before {
    display: block;
    content: "\201C";
    font-size: 4.41226rem;
    position: absolute;
    left: 0;
    top: -12px;
    color: rgba(108, 113, 117, 0.5); }
  blockquote > :nth-child(1) {
    margin-top: 0; }

ul,
ol {
  margin-left: 2rem; }
  ul > li,
  ol > li {
    list-style: inherit;
    padding: 0 0 0.26667rem 0.26667rem; }

dl dt {
  color: #262626;
  font-weight: 600; }

code,
pre {
  background-color: #f1f1f1;
  font-family: monospace; }

pre {
  margin: 1.6rem 0 0;
  padding: 1.6rem;
  white-space: pre-wrap;
  word-wrap: break-word;
  overflow-x: auto; }
  pre > code {
    color: #262626;
    padding: 0; }

code {
  border-radius: 3px;
  color: #262626;
  padding: 0.26667rem 0.53333rem; }

table {
  border-collapse: collapse;
  border-spacing: 0;
  border: 1px solid #d4d4d4;
  width: 100%;
  overflow-x: auto;
  vertical-align: top;
  text-align: left;
  white-space: nowrap; }
  table th {
    font-weight: 500;
    padding: 0.53333rem 1.06667rem; }
  table tr {
    border-bottom: 1px solid #d4d4d4; }
    table tr:nth-child(2n) {
      background: #f1f1f1; }
  table td {
    padding: 0.53333rem 1.06667rem; }

figcaption {
  clear: both;
  color: rgba(108, 113, 117, 0.6);
  font-size: 0.82397rem;
  margin: 0.8rem 0 0;
  text-align: center; }

sub,
sup {
  font-size: 65%; }

hr {
  border: 0;
  height: 0;
  border-top: 1px solid rgba(0, 0, 0, 0.1);
  border-bottom: 1px solid rgba(255, 255, 255, 0.3); }

.btn, [type=button],
[type=submit],
button {
  background: #039be5;
  border: none;
  border-radius: 2px;
  color: #ffffff;
  cursor: pointer;
  display: inline-block;
  font-size: 0.87891rem;
  font-weight: 500;
  line-height: 1.9;
  padding: 0.53333rem 1.33333rem;
  text-align: center;
  text-decoration: none;
  -webkit-transition: all .15s ease;
  -o-transition: all .15s ease;
  transition: all .15s ease;
  width: auto; }
  .btn:hover, [type=button]:hover,
  [type=submit]:hover,
  button:hover {
    background: #262626;
    color: #ffffff; }
  .btn:focus, [type=button]:focus,
  [type=submit]:focus,
  button:focus {
    outline: none; }
  .btn-outline {
    border: 1px solid #ddd;
    background: #ffffff;
    border-radius: 3px;
    color: #262626; }

[type=button],
[type=submit],
button {
  text-transform: uppercase;
  -webkit-appearance: none;
  -moz-appearance: none; }

.navbar {
  background: #039be5;
  -webkit-box-shadow: 0 0 6px 0 rgba(0, 0, 0, 0.2);
  box-shadow: 0 0 6px 0 rgba(0, 0, 0, 0.2);
  line-height: 3;
  max-height: 4rem; }
  .navbar > div {
    -webkit-box-align: center;
    -ms-flex-align: center;
    align-items: center;
    display: -webkit-box;
    display: -ms-flexbox;
    display: flex;
    -webkit-box-pack: center;
    -ms-flex-pack: center;
    justify-content: center;
    text-align: left;
    max-width: 700px;
    margin: 0 auto; }
  .navbar a {
    color: #ffffff;
    text-decoration: none; }
  .navbar-sidebar-toggle {
    left: 0;
    position: relative;
    text-indent: -99999rem; }
    .navbar-sidebar-toggle:before {
      content: "";
      display: block;
      border-top: 0.375rem double #ffffff;
      border-bottom: 0.125rem solid #ffffff;
      height: 0.125rem;
      position: absolute;
      text-indent: 0;
      top: 50%;
      width: 1.3rem;
      -webkit-transform: translate(0px, -50%);
      -ms-transform: translate(0px, -50%);
      transform: translate(0px, -50%); }


.logo {
            display: inline-block;
  font-weight: 600;
  line-height: 1;
            margin: 0 auto;
            height: 2rem;
            text-indent: -9999px;
            width: 240px;vertical-align: middle;
        }
        .logo.logo-text {
            line-height: 2;
            text-align: center;
            text-indent: 0;
        }

amp-sidebar {
  background: #ffffff;
  width: 240px; }
  amp-sidebar > ul {
    margin: 0.8rem 0 0;
    padding: 0; }
    amp-sidebar > ul ul {
      border-left: 1px solid #d4d4d4;
      margin: 0.53333rem 0 0; }
    amp-sidebar > ul li {
      color: #262626;
      font-size: 0.9375rem;
      font-weight: 600;
      list-style: none;
      line-height: 1.4;
      padding: 0.42667rem 1.06667rem; }
      amp-sidebar > ul li li {
        font-weight: normal;
        padding: 0.26667rem 0 0.26667rem 1.06667rem; }
    amp-sidebar > ul a,
    amp-sidebar > ul a:visited {
      color: #262626; }

.bg-white {
  background: #ffffff; }

.wrap-page {
  max-width: 700px;
  margin: 0 auto; }

@media all and (max-width: 43.6875em) {
  .wrap-inner {
    padding: 0 6%; } }

.page-title {
  background: #ffffff;
  -webkit-box-shadow: 0 2px 3px rgba(38, 38, 38, 0.1);
  box-shadow: 0 2px 3px rgba(38, 38, 38, 0.1);
  margin-bottom: 0.8rem;
  padding: 1.6rem 6%; }
  .page-title > h1 {
    margin: 0;
    font-size: 1.29454rem; }
  .page-title > p {
    font-size: 0.87891rem;
    color: #6c7175;
    line-height: 1.3;
    margin: 0.26667rem 0 0; }
  .page-title-author {
    border-radius: 50%;
    float: left;
    height: 2.5rem;
    width: 2.5rem; }
    .page-title-author + h1 {
      margin-left: 3.5rem; }
      .page-title-author + h1 + p {
        margin-left: 3.5rem; }

.card {
  background: #ffffff;
  -webkit-box-shadow: 0 2px 3px rgba(38, 38, 38, 0.1);
  box-shadow: 0 2px 3px rgba(38, 38, 38, 0.1);
  margin-bottom: 0.8rem;
  padding-bottom: 1.06667rem; }

  .card-meta {
    border-top: 1px solid #d4d4d4;
    color: rgba(108, 113, 117, 0.6);
    font-size: 0.7242rem;
    font-weight: 500;
    margin-top: 1.06667rem;
    padding-top: 1.06667rem;
    text-transform: uppercase; }
    .card-meta a + time:before {
      content: "";
      background: #d4d4d4;
      display: inline-block;
      height: 3px;
      margin: 0 8px;
      width: 3px;
      vertical-align: middle;
      border-radius: 50%; }
  .card-text {
    font-size: 0.9375rem;
    overflow: hidden;
    padding: 0 6%; }
    .card-text h2 {
      font-size: 1.13778rem; }

.post {
  margin-bottom: 2.13333rem; }
  .post-featured-image {
    margin-top: 0;
    position: relative; }
    .post-featured-image > figcaption {
      background: rgba(0, 0, 0, 0.5);
      border-radius: 3px;
      color: #ffffff;
      position: absolute;
      bottom: 0.8rem;
      padding: 0 0.26667rem;
      right: 6%; }
  .post-header {
    margin-bottom: 2.13333rem; }
  .post-meta {
    border-bottom: 1px solid #d4d4d4;
    color: rgba(108, 113, 117, 0.6);
    font-size: 0.7242rem;
    font-weight: 500;
    margin-top: 1.06667rem;
    padding-bottom: 1.06667rem;
    text-transform: uppercase; }
    .post-meta a + time:before {
      content: "";
      background: #d4d4d4;
      display: inline-block;
      height: 3px;
      margin: 0 8px;
      width: 3px;
      vertical-align: middle;
      border-radius: 50%; }
  .post-tag {
    margin: 0; }
    .post-tag > li {
      display: inline-block;
      padding: 0; }
      .post-tag > li a {
        background: #f1f1f1;
        border-radius: 2px;
        color: #6c7175;
        font-size: 0.77248rem;
        display: inline-block;
        margin: 0 0.26667rem 0.26667rem 0;
        padding: 0.26667rem 0.53333rem; }
        .post-tag > li a:hover {
          background: #039be5;
          color: #ffffff;
          text-decoration: none; }
  .post-share {
    display: -webkit-box;
    display: -ms-flexbox;
    display: flex;
    -webkit-box-orient: horizontal;
    -webkit-box-direction: normal;
    -ms-flex-direction: row;
    flex-direction: row;
    -webkit-box-pack: justify;
    -ms-flex-pack: justify;
    justify-content: space-between;
    margin-top: 1.6rem;
    width: 100%; }
    .post-share amp-social-share {
      -webkit-box-flex: 1;
      -ms-flex: 1 0 auto;
      flex: 1 0 auto;
      background-size: 24px; }
  .post-scroll {
    color: #ffffff;
    background: #039be5;
    bottom: 10px;
    border-radius: 50%;
    border: none;
    -webkit-box-shadow: 0 1px 1.5px 0 rgba(38, 38, 38, 0.12), 0 1px 1px 0 rgba(38, 38, 38, 0.24);
    box-shadow: 0 1px 1.5px 0 rgba(38, 38, 38, 0.12), 0 1px 1px 0 rgba(38, 38, 38, 0.24);
    font-size: 1.13778rem;
    height: 46px;
    opacity: 0;
    outline: none;
    position: fixed;
    padding: 0;
    right: 4%;
    visibility: hidden;
    width: 46px;
    z-index: 9999; }
    .post-scroll-marker {
      height: 0px;
      position: absolute;
      top: 100px;
      width: 0px; }
        .post-pagination {
    background: #f1f1f1;
    -webkit-box-shadow: inset 0 2px 3px rgba(38, 38, 38, 0.1);
    box-shadow: inset 0 2px 3px rgba(38, 38, 38, 0.1);
    border-top: 1px solid #d4d4d4;
    padding: 1.06667rem 0; }
    .post-pagination > div {
      line-height: 1.2;
      padding: 0.53333rem 1.06667rem;
      text-align: center; }
      .post-pagination > div span {
        display: block;
        color: #6c7175;
        font-size: 0.7242rem;
        font-weight: 500;
        margin-bottom: 0.26667rem;
        text-transform: uppercase; }
    .post-pagination-prev a:before {
      content: "\2190";
      margin-right: 0.26667rem; }
    .post-pagination-next a:after {
      content: "\2192";
      margin-left: 0.26667rem; }

aside {
  margin: 1.6rem 0 0; }

.align-left {
  text-align: left; }

.align-right {
  text-align: right; }

.align-center {
  text-align: center; }

.align-justify {
  text-align: justify; }

.msg {
  border-left: 2px solid transparent;
  padding: 1.06667rem 1.06667rem; }
  .msg--highlight {
    background-color: #fff8e6;
    border-color: #e2ac4f; }
  .msg--info {
    background: rgba(45, 97, 201, 0.03);
    border-color: #039be5; }
  .msg--success {
    background: #f7fbf6;
    border-color: #5ab44b; }
  .msg--warning {
    background: #fff3f3;
    border-color: #c06367;
    color: #a94442; }

.dropcap:first-letter {
  float: left;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif;
  font-size: 2.16943rem;
  line-height: 0.7;
  margin-right: 0.53333rem;
  padding: 0.53333rem 0.53333rem 0.53333rem 0; }

.pagination {
  display: -webkit-box;
  display: -ms-flexbox;
  display: flex;
  -webkit-box-pack: justify;
  -ms-flex-pack: justify;
  justify-content: space-between;
  margin: 0.8rem 0; }
  .pagination > a {
    padding-left: 0;
    padding-right: 0;
    width: 49%; }
  .pagination-right {
    margin-left: auto; }

.bottom {
  background: #039be5;
  color: #ffffff;
  padding: 1.06667rem 4%;
  text-align: center; }</style><style amp-boilerplate>body{-webkit-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-moz-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-ms-animation:-amp-start 8s steps(1,end) 0s 1 normal both;animation:-amp-start 8s steps(1,end) 0s 1 normal both}@-webkit-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-moz-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-ms-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-o-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}</style><noscript><style amp-boilerplate>body{-webkit-animation:none;-moz-animation:none;-ms-animation:none;animation:none}</style></noscript><script async src="https://cdn.ampproject.org/v0.js"></script><script custom-element="amp-animation" src="https://cdn.ampproject.org/v0/amp-animation-0.1.js" async></script><script custom-element="amp-position-observer" src="https://cdn.ampproject.org/v0/amp-position-observer-0.1.js" async></script></head><body class="bg-white"><nav class="navbar wrap-inner" id="top"><div><a on="tap:navbar-sidebar.toggle" class="navbar-sidebar-toggle" title="Menu">Menu</a> <a class="logo logo-text" href="https://propiro.github.io/amp/">propiro.github.io</a></div></nav><main class="wrap-page"><article class="post"><div class="wrap-inner"><header class="post-header"><h1>MAXSCRIPT: InsetFix Smoothgroup Modifier</h1><p class="post-meta">[MISSING TRANSLATION] <a href="https://propiro.github.io/amp/authors/piro/" rel="nofollow" title="piro">piro</a> <time datetime="2023-02-15T11:03">15/02/2023</time></p></header><p>Note: This script isn't mine, but its made by very talented Vojtech Cada - I'm reposting it here mostly for myself, so I wont lose it, and to show some viewers. Original link it was grabbed from is: <a href="http://www.scriptspot.com/3ds-max/scripts/insetfix-modifier">http://www.scriptspot.com/3ds-max/scripts/insetfix-modifier</a><a href="http://www.scriptspot.com/3ds-max/scripts/insetfix-modifier"></a></p><p>Some time ago I've included InsetFix to my workflow, and it speeds up modelling by a lot. See the difference between build-in 3ds max inset (left), applied per-smoothgroup, and InsetFix (right):</p><figure class="post__image"><amp-img src="https://propiro.github.io/media/posts/38/2023-02-15_11h00_15.png" sizes="(min-width: 1500px) calc(7.87vw + 610px), (min-width: 900px) calc(44.48vw + 68px), (min-width: 780px) calc(8vw + 604px), calc(84.35vw + 23px)" srcset="https://propiro.github.io/media/posts/38/responsive/2023-02-15_11h00_15-xs.png 300w ,https://propiro.github.io/media/posts/38/responsive/2023-02-15_11h00_15-sm.png 480w ,https://propiro.github.io/media/posts/38/responsive/2023-02-15_11h00_15-md.png 768w" alt="" width="2392" height="1772" layout="responsive"></amp-img><figcaption>All the corners, nicely prepared for applying meshsmooth!</figcaption></figure><p>As you can see, after mesh have correctly set smoothgroups, it automatically creates good base topology for applying subdivision, with corners protected by edges.</p><p>Code for script, in case you cant download it from scriptspot anymore - save it as InsetFix.ms, put in startup folder (or execute manually every time), and you'll find InsetFix on modifier list:</p><p><code>plugin simpleMeshMod insetSGFix</code><br><code>    name:"InsetSGFix"</code><br><code>    classID:#(0xc4e63a8, 0x2a9ccb40)</code><br><code>--    author:"Vojtech Cada"</code><br><code>(</code><br><code>    parameters main rollout:params</code><br><code>    (</code><br><code>        inset type:#worldUnits default:0 ui:spnInset</code><br><code>    )</code><br><br><code>    rollout params "Parameters"</code><br><code>    (</code><br><code>        spinner spnInset "Inset: " type:#worldUnits range:[1e-9, 1e9, 0]</code><br><code>    )</code><br><br><code>    local faceIndex</code><br><br><code>    fn getFaceEdge face edge =</code><br><code>        (face - 1) * 3 + edge</code><br><br><code>    fn getFaceVert face index =</code><br><code>        int (getFace mesh face)[index]</code><br><br><code>    fn getReverseEdge edge =</code><br><code>        ((meshop.getEdgesReverseEdge mesh edge) as array)[1]</code><br><br><code>    fn getProjectedInset edge =</code><br><code>        meshop.getVert mesh edge.insetVertA - edge.vertAPos</code><br><br><code>    struct orientedEdge</code><br><code>    (</code><br><code>        -- vert indices:</code><br><code>        vertA, vertAPos, insetVertA, innerVertA = vertA, innerInsetVertA,</code><br><code>        vertB, vertBPos, insetVertB, innerVertB = vertB, innerInsetVertB,</code><br><br><code>        face, -- the face that the edge belongs to</code><br><code>        vertAFaceIndex, -- index of vertA in the face</code><br><code>        vertBFaceIndex, -- index of vertB in the face</code><br><br><code>        isEdgeCornerAReflex = false, innerOffsetA,</code><br><code>        isEdgeCornerBReflex = false, innerOffsetB,</code><br><br><code>        smoothGroup,</code><br><code>        active = true, -- when active, no faces were created for this edge yet</code><br><code>        divided = false,</code><br><code>        dir = normalize (vertBPos - vertAPos), -- edge direction</code><br><code>        index = (face - 1) * 3 + vertAFaceIndex, -- edge index</code><br><br><code>        fn getInsetVert vertFaceIndex =</code><br><code>            getFaceVert face vertFaceIndex,</code><br><br><code>        fn getEdgeDiv offset =</code><br><code>            offset / distance (meshop.getVert mesh insetVertA) \</code><br><code>                              (meshop.getVert mesh insetVertB),</code><br><br><code>        fn insertCornerVertA div =</code><br><code>        (</code><br><code>            meshop.divideEdge mesh index (getEdgeDiv div) fixNeighbors:false</code><br><code>            innerInsetVertA = mesh.numVerts</code><br><code>        ),</code><br><br><code>        fn insertCornerVertB div =</code><br><code>        (</code><br><code>            meshop.divideEdge mesh index (1 - getEdgeDiv div) fixNeighbors:false</code><br><code>            innerInsetVertB = mesh.numVerts</code><br><code>        ),</code><br><br><code>        fn initInsetVerts =</code><br><code>        (</code><br><code>            innerInsetVertA = insetVertA = getInsetVert vertAFaceIndex</code><br><code>            innerInsetVertB = insetVertB = getInsetVert vertBFaceIndex</code><br><code>        )</code><br><code>    )</code><br><br><code>    struct edgePair</code><br><code>    (</code><br><code>        smoothGroup,</code><br><br><code>        edgeA, edgeReverseA,</code><br><code>        edgeB, edgeReverseB,</code><br><br><code>        innerEdgeA = getReverseEdge edgeA.index,</code><br><code>        innerEdgeB = getReverseEdge edgeB.index,</code><br><br><code>        innerOffset = dot edgeA.dir (getProjectedInset edgeA),</code><br><code>        isAngleReflex = innerOffset &lt; 0,</code><br><code>        isEdgeCornerReflex,</code><br><br><code>        fn insertCornerVertA = edgeA.insertCornerVertA (inset - innerOffset),</code><br><code>        fn insertCornerVertB = edgeB.insertCornerVertB (inset - innerOffset),</code><br><br><code>        fn insertCornerVerts edge =</code><br><code>        (</code><br><code>            local divA = edge.getEdgeDiv (inset - edge.innerOffsetA)</code><br><code>            local divB = edge.getEdgeDiv (inset - edge.innerOffsetB)</code><br><br><code>            meshop.divideEdge mesh edge.index divA fixNeighbors:false</code><br><code>            meshop.divideEdge mesh edge.index (1 - divB / (1 - divA)) fixNeighbors:false</code><br><br><code>            edge.innerInsetVertB = mesh.numVerts</code><br><code>            edge.innerInsetVertA = edge.innerInsetVertB - 1 </code><br><code>        ),</code><br><br><code>        fn divideEdge edge isEdgeCornerReflex insertCornerVert =</code><br><code>            if isEdgeCornerReflex then</code><br><code>            (</code><br><code>                if not edge.divided do</code><br><code>                (</code><br><code>                    insertCornerVerts edge</code><br><code>                    edge.divided = true</code><br><code>                )</code><br><code>            )</code><br><code>            else insertCornerVert(),</code><br><br><code>        fn divideEdgeA = divideEdge edgeA edgeA.isEdgeCornerBReflex insertCornerVertA,</code><br><code>        fn divideEdgeB = divideEdge edgeB edgeB.isEdgeCornerAReflex insertCornerVertB,</code><br><br><code>        fn addCornerFaces =</code><br><code>            if isAngleReflex then</code><br><code>            (</code><br><code>                meshop.createPolygon mesh #(edgeA.vertA, edgeA.innerVertA, edgeA.innerInsetVertA, edgeA.insetVertA)</code><br><code>                meshop.createPolygon mesh #(edgeB.innerVertB, edgeB.vertB, edgeB.insetVertB, edgeB.innerInsetVertB)</code><br><code>                faceIndex += 4</code><br><code>                #{getFaceEdge (faceIndex - 3) 1, getFaceEdge (faceIndex - 1) 2}</code><br><code>            )</code><br><code>            else</code><br><code>            (</code><br><code>                meshop.createPolygon mesh #(edgeA.vertA, edgeA.innerVertA, edgeA.insetVertA, edgeB.innerVertB)</code><br><code>                faceIndex += 2</code><br><code>                #{getFaceEdge (faceIndex - 1) 1, getFaceEdge (faceIndex) 3}</code><br><code>            ),</code><br><br><code>        fn addJointQuads =</code><br><code>        ((</code><br><code>            if not edgeA.active then #{} else</code><br><code>            (</code><br><code>                meshop.createPolygon mesh #(edgeA.innerVertA, edgeA.innerVertB, edgeA.innerInsetVertB, edgeA.innerInsetVertA)</code><br><code>                faceIndex += 2</code><br><code>                #{getFaceEdge (faceIndex - 1) 1}</code><br><code>            )) + (</code><br><code>            if not edgeB.active then #{} else</code><br><code>            (</code><br><code>                meshop.createPolygon mesh #(edgeB.innerInsetVertA, edgeB.innerVertA, edgeB.innerVertB, edgeB.innerInsetVertB)</code><br><code>                faceIndex += 2</code><br><code>                #{getFaceEdge (faceIndex - 1) 2}</code><br><code>            ))</code><br><code>        ),</code><br><br><code>        on create do</code><br><code>        (</code><br><code>            edgeA.isEdgeCornerAReflex = edgeB.isEdgeCornerBReflex = isAngleReflex</code><br><code>            edgeA.innerOffsetA = edgeB.innerOffsetB = innerOffset</code><br><code>        )</code><br><code>    )</code><br><br><code>    struct corner</code><br><code>    (</code><br><code>        edges,</code><br><code>        reverseEdges,</code><br><code>        oppositeEdges = #(),</code><br><code>        edgePairs,</code><br><br><code>        on create do edgePairs =</code><br><code>            for i = 1 to edges.count collect</code><br><code>            (</code><br><code>                local edgeA = edges[i]</code><br><code>                local edgeB = reverseEdges[i]</code><br><code>                edgeA.initInsetVerts()</code><br><code>                edgeB.initInsetVerts()</code><br><br><code>                edgePair smoothGroup:edgeA.smoothGroup edgeA:edgeA edgeB:edgeB \</code><br><code>                         edgeReverseA:(for edge in reverseEdges where edge.vertA == edgeA.vertB do exit with edge) \</code><br><code>                         edgeReverseB:(for edge in edges where edge.vertB == edgeB.vertA do exit with edge)</code><br><code>            )</code><br><code>    )</code><br><br><code>    fn comparevertA i1 i2 =</code><br><code>        if i1.vertA == i2.vertA then</code><br><code>            i1.smoothGroup - i2.smoothGroup</code><br><code>        else i1.vertA - i2.vertA</code><br><br><code>    fn comparevertB i1 i2 =</code><br><code>        if i1.vertB == i2.vertB then</code><br><code>            i1.smoothGroup - i2.smoothGroup</code><br><code>        else i1.vertB - i2.vertB</code><br><br><code>    fn wrapFaceIndex index =</code><br><code>        int(mod (index - 1) 3) + 1</code><br><br><code>    fn getEdgeFace edge =</code><br><code>        if edge == undefined then 0 else (edge - 1) / 3 + 1</code><br><br><code>    fn getReverseFace edge =</code><br><code>        getEdgeFace (getReverseEdge edge)</code><br><br><code>    fn getOppositeFace face edge =</code><br><code>        getReverseFace (getFaceEdge face edge)</code><br><br><code>    fn makeEdge index face faceVerts smoothGroup =</code><br><code>    (</code><br><code>        local vertA = int faceVerts[index]</code><br><code>        local vertB = int faceVerts[wrapFaceIndex (index + 1)]</code><br><br><code>        orientedEdge vertA:vertA vertAPos:(meshop.getVert mesh vertA) \</code><br><code>                     vertB:vertB vertBPos:(meshop.getVert mesh vertB) \</code><br><code>                     vertAFaceIndex:index vertBFaceIndex:(wrapFaceIndex (index + 1)) \</code><br><code>                     face:face smoothGroup:smoothGroup</code><br><code>    )</code><br><br><code>    fn getSGElements mesh =</code><br><code>    (</code><br><code>        local vertCount = mesh.numVerts</code><br><code>        local done = #{}, faces = mesh.faces as bitArray -- all the mesh face indices, will be eliminated one by one</code><br><code>        local facesByVert = for v = 1 to vertCount collect #() -- list of faces sharing the individual verts, filled in the next step:</code><br><br><code>        for face in faces do</code><br><code>        (</code><br><code>            local faceVerts = getFace mesh face</code><br><code>            append facesByVert[faceVerts[1]] face</code><br><code>            append facesByVert[faceVerts[2]] face</code><br><code>            append facesByVert[faceVerts[3]] face</code><br><code>        )</code><br><br><code>        -- collect and return element data:</code><br><code>        for face in faces collect</code><br><code>        (</code><br><code>            local i = 0 -- dynamic index, incremented in while loop, tries to get next appended face</code><br><code>            local element = #(face) -- get one of the remaining faces</code><br><code>            local border = #() -- SG border verts</code><br><code>            local elementSG = getFaceSmoothGroup mesh face -- get its SG</code><br><br><code>            -- while there's still at least one other face appended in the previous while iteration:</code><br><code>            while (local f = element[i += 1]) != undefined do if faces[f] /* and we haven't seen that face before */ do</code><br><code>            (</code><br><code>                faces[f] = false -- remove that face from candidate pool</code><br><code>                append done f -- could be merged with faces check, though it reads easier this way</code><br><code>                local faceVerts = getFace mesh f -- get its three verts</code><br><code>                local vertBuffer = 0 -- face verts sharing different SG encoded as bits</code><br><code>                local faceBuffer = #{} -- faces across the SG border</code><br><br><code>                for v = 1 to 3 do</code><br><code>                (</code><br><code>                    local vert = int(faceVerts[v]) -- indexed face vertex</code><br><br><code>                    -- for faces sharing the given vert:</code><br><code>                    for vertFace in facesByVert[vert] do</code><br><code>                        if getFaceSmoothGroup mesh vertFace == elementSG then -- it's the same SG</code><br><code>                            if not done[vertFace] do -- we haven't seen it before</code><br><code>                            (</code><br><code>                                append element vertFace -- append it to the current element</code><br><code>                                append done vertFace -- append to the list of previously appended faces</code><br><code>                            )</code><br><code>                        else -- doesn't share the same SG</code><br><code>                        (</code><br><code>                            vertBuffer = bit.set vertBuffer v true -- add the vertex to SG border verts buffer</code><br><code>                            faceBuffer[vertFace] = true -- add the face to border face buffer</code><br><code>                            vertFace -- collect it with the rest of remaining facesByVert</code><br><code>                        )</code><br><code>                )</code><br><br><code>                case vertBuffer of</code><br><code>                (</code><br><code>                    3: if (fInv = getOppositeFace f 1) == 0 or faceBuffer[fInv] do </code><br><code>                        append border (makeEdge 1 f faceVerts elementSG) -- verts 1 and 2</code><br><code>                    6: if (fInv = getOppositeFace f 2) == 0 or faceBuffer[fInv] do</code><br><code>                        append border (makeEdge 2 f faceVerts elementSG) -- verts 2 and 3</code><br><code>                    5: if (fInv = getOppositeFace f 3) == 0 or faceBuffer[fInv] do</code><br><code>                        append border (makeEdge 3 f faceVerts elementSG) -- verts 1 and 3</code><br><code>                    7: for ei = 1 to 3 where (fInv = getOppositeFace f ei) == 0 or faceBuffer[fInv] do</code><br><code>                        append border (makeEdge ei f faceVerts elementSG) -- verts 1, 2, 3</code><br><code>                )</code><br><code>            )</code><br><br><code>             -- collect a tuple (faces with the same SG, SG border edges):</code><br><code>            dataPair faces:(element as bitArray) border:border</code><br><code>        )</code><br><code>    )</code><br><br><code>    fn cornersFromSortedBorder border type: =</code><br><code>    (</code><br><code>        local i = 1, edgeCount = border.count</code><br><code>        local corners = #()</code><br><br><code>        while i &lt; edgeCount do</code><br><code>        (</code><br><code>            local vert = getProperty border[i] type</code><br><code>            local corner = #()</code><br><br><code>            -- append one and continue getting while the ones following share the same index:</code><br><code>            do append corner border[i]</code><br><code>            while i &lt; edgeCount and getProperty border[i += 1] type == vert</code><br><br><code>            append corners corner</code><br><code>        )</code><br><code>        return corners</code><br><code>    )</code><br><br><code>    on modifyMesh do</code><br><code>    (</code><br><code>        local border = #(), selectedEdges = #(), facesToDelete = #{}</code><br><code>        local faceCount = mesh.numFaces</code><br><code>        local elements = getSGElements mesh</code><br><br><code>        for element in elements do</code><br><code>        (</code><br><code>            meshOp.extrudeFaces mesh element.faces 0 -inset</code><br><code>            join border element.border</code><br><code>        )</code><br><br><code>        if mesh.numFaces &gt; faceCount do</code><br><code>        (</code><br><code>            -- select new faces:</code><br><code>            local selectedFaces = setFaceSelection mesh #{faceCount + 1 .. mesh.numFaces} as array</code><br><br><code>            -- collect new edges for selection:</code><br><code>            local edge = (selectedFaces[1] - 1) * 3 + 1</code><br><code>            local selectedEdges = #{edge}</code><br><code>            for f = 3 to selectedFaces.count by 2 do append selectedEdges (edge += 6)</code><br><br><code>            -- sort all the border verts by the first edge vertex index:</code><br><code>            qSort border comparevertA</code><br><code>            local corners = cornersFromSortedBorder border type:#vertA</code><br><br><code>            -- sort all the border verts by the second edge vertex index:</code><br><code>            qSort border comparevertB</code><br><code>            local reverseCorners = cornersFromSortedBorder border type:#vertB</code><br><br><code>            -- corners sharing more than two smoothing groups:</code><br><code>            local multiCorners = for c = 1 to corners.count where corners[c].count &gt; 2 collect</code><br><code>                corner edges:corners[c] reverseEdges:reverseCorners[c]</code><br><br><code>            -- get corner support points count:</code><br><code>            local cornerPtsCount = 0</code><br><code>            for corner in multiCorners do cornerPtsCount += corner.edges.count</code><br><br><code>            -- add corner support points:</code><br><code>            local vertCount = mesh.numVerts</code><br><code>            setNumVerts mesh (vertCount + cornerPtsCount) true</code><br><br><code>            -- set and add vertices:</code><br><code>            for corner in multiCorners do for pair in corner.edgePairs do</code><br><code>            (</code><br><code>                setVert mesh (vertCount += 1) (pair.edgeA.vertAPos + inset * pair.edgeA.dir)</code><br><code>                pair.edgeA.innerVertA = pair.edgeReverseA.innerVertB = vertCount</code><br><br><code>                if pair.isAngleReflex do</code><br><code>                (</code><br><code>                    pair.divideEdgeA()</code><br><code>                    pair.divideEdgeB()</code><br><code>                )</code><br><code>            )</code><br><br><code>            faceIndex = mesh.numFaces</code><br><br><code>            -- add polygons:</code><br><code>            for corner in multiCorners do for pair in corner.edgePairs do</code><br><code>            (</code><br><code>                join facesToDelete (meshop.getPolysUsingEdge mesh pair.innerEdgeA)</code><br><code>                join facesToDelete (meshop.getPolysUsingEdge mesh pair.innerEdgeB)</code><br><br><code>                selectedEdges += pair.addCornerFaces()</code><br><code>                selectedEdges += pair.addJointQuads()</code><br><br><code>                -- mark all used edges inactive:</code><br><code>                pair.edgeA.active = false</code><br><code>                pair.edgeB.active = false</code><br><code>            )</code><br><br><code>            setEdgeSelection mesh selectedEdges</code><br><code>            meshop.deleteFaces mesh facesToDelete delIsoVerts:false</code><br><code>        )</code><br><code>    )</code><br><code>)</code></p><p> </p><p> </p><p> </p><aside><ul class="post-tag"><li><a href="https://propiro.github.io/amp/3d-tag/">3d</a></li><li><a href="https://propiro.github.io/amp/maxscript/">maxscript</a></li><li><a href="https://propiro.github.io/amp/quick_3d_tips/">quick_3d_tips</a></li></ul><div class="post-share"><amp-social-share type="system" width="40" height="40" data-param-text="MAXSCRIPT: InsetFix Smoothgroup Modifier"></amp-social-share><amp-social-share type="facebook" width="40" height="40" data-param-app_id="" data-param-text="MAXSCRIPT: InsetFix Smoothgroup Modifier" data-param-href="https://propiro.github.io/amp/macroscript-insetfix-smoothgroup-modifier.html"></amp-social-share><amp-social-share type="twitter" width="40" height="40" data-param-text="MAXSCRIPT: InsetFix Smoothgroup Modifier" data-param-url="https://propiro.github.io/amp/macroscript-insetfix-smoothgroup-modifier.html"></amp-social-share><amp-social-share type="pinterest" width="40" height="40" data-param-url="https://propiro.github.io/amp/macroscript-insetfix-smoothgroup-modifier.html"></amp-social-share><amp-social-share type="tumblr" width="40" height="40" data-param-text="MAXSCRIPT: InsetFix Smoothgroup Modifier" data-param-url="https://propiro.github.io/amp/macroscript-insetfix-smoothgroup-modifier.html"></amp-social-share><amp-social-share type="whatsapp" width="40" height="40" data-param-text="MAXSCRIPT: InsetFix Smoothgroup Modifier" data-param-url="https://propiro.github.io/amp/macroscript-insetfix-smoothgroup-modifier.html"></amp-social-share></div></aside></div></article></main><amp-animation id="showAnim" layout="nodisplay"><script type="application/json">{
                    "duration": "200ms",
                    "fill": "both",
                    "iterations": "1",
                    "direction": "alternate",
                    "animations": [{
                        "selector": ".post-scroll",
                        "keyframes": [{
                            "opacity": "1",
                            "visibility": "visible",
                            "transform": "scale(1)"
                        }]
                    }]
                }</script></amp-animation><amp-animation id="hideAnim" layout="nodisplay"><script type="application/json">{
                    "duration": "200ms",
                    "fill": "both",
                    "iterations": "1",
                    "direction": "alternate",
                    "animations": [{
                        "selector": ".post-scroll",
                        "keyframes": [{
                            "opacity": "0",
                            "visibility": "hidden",
                            "transform": "scale(0.1)"
                        }]
                    }]
                }</script></amp-animation><div class="post-scroll-marker"><amp-position-observer on="enter:hideAnim.start; exit:showAnim.start" layout="nodisplay"></amp-position-observer></div><button class="post-scroll" on="tap:top.scrollTo(duration=200)">&#8593;</button><footer class="bottom">Powered by Publii</footer><amp-sidebar id="navbar-sidebar" layout="nodisplay"><ul><li><span>./MAIN/</span></li><li><a href="https://propiro.github.io/amp//">./MAIN/ALL</a></li><li><span>./MAIN/WORK/</span><ul class="navbar__submenu"><li><a href="https://propiro.github.io/amp/maxscript/" target="_self">./MAIN/WORK/maxscript/</a></li><li><a href="https://propiro.github.io/amp/3d-tag/" target="_self">./MAIN/WORK/3d/</a></li><li><a href="https://propiro.github.io/amp/gamedev/" target="_self">./MAIN/WORK/gamedev/</a></li></ul></li><li><a href="https://propiro.github.io/amp/hacks/">./MAIN/SOCIAL/</a><ul class="navbar__submenu"><li><a href="https://propiro.github.io/amp/internet/" target="_self">./MAIN/SOCIAL/internet/</a></li><li><a href="https://propiro.github.io/amp/general_rant/" target="_self">./MAIN/SOCIAL/rant/</a></li><li><a href="https://propiro.github.io/amp/other/" target="_self">./MAIN/SOCIAL/misc</a></li><li class="has-submenu"><span>./MAIN/SOCIAL/friend_sites</span><ul class="navbar__submenu"><li><a href="https://pidpawel.eu" target="_self">/pid</a></li></ul></li></ul></li><li><a href="https://propiro.github.io/amp/shopping/">./MAIN/NOT_WORK/</a><ul class="navbar__submenu"><li><a href="https://propiro.github.io/amp/hacks/" target="_self">./MAIN/NOT_WORK/hacks/</a></li><li><a href="https://propiro.github.io/amp/shopping/" target="_self">./MAIN/NOT_WORK/shopping</a></li><li><a href="https://propiro.github.io/amp/diy/" target="_self">./MAIN/NOT_WORK/diy/</a></li><li><a href="https://propiro.github.io/amp/hardware/" target="_self">./MAIN/NOT_WORK/hardware/</a></li></ul></li></ul></amp-sidebar></body></html>